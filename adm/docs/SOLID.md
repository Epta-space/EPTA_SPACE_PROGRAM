# SOLID software development patterns:
---
Here we will study some good practices in software development, with the SOLID design patterns made for object oriented programming. It's described by the acronym S.O.L.I.D where each letter representes a principle for better code writing. All of then were made by the famous uncle bob and are as follows:

- S: Single responsibility principle;
- O: Open close principle;
- L: Liskov substitution principle;
- I: Interface segregation principle;
- D: Dependency inversion principle;

## S : Single Responsibility Principle: Every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class, module or function. A class should have one, and only one, reason to change. (Robert C. Martin - UNCLE BOB)

A program is like a workshop. Where you can do all sorts of things. If a bunch of stuff is done in the workshop it's natural that there would be lots and lots of tools and equipment there. As an example, if you create furniture in this workshop, there shall be a handsaw or hammer with nails, and surely lots of wood. So, in this situation you have two options of organizing things. One is leaving all things scattered in the room, on the floor and hanging on the walls. And the other is keeping stuff in small and regular boxes well named and organized. The second option works best. We call those boxes "Classes" around here. These classes are good to label functionalities and keep then separated in different files (boxes). Each class should keep functions or information that are correlated. And they should have one and just one objective. There should be a hammer class, ready to hammer anything that we should smash. We shouldn't smash a nail in the wood using anything other than the hammer class. And there should be only one box for this. There may be numerous hammers of a diversity of shapes and sizes, but they all should be in the same box, the hammer box. And if a nail breaks when you are doing a table, you know were is the problem, maybe you used the wrong hammer, or maybe you need a new one, but you know were the problem is and you know what must be done. Besides that, if we start putting things in the same box, that box would start growing and we would end with a file with thousands of lines. That would be even worst than having things scattered through the workshop. So that's it, let's maintain things separated, labeled and organized. That is the power of the single Responsibility principle. This is important too because this separate responsibilities, the result is a code where you don't need to understand everything to change something, what isn't good for large projects. Each class should have a unique reason to exist and to change.

## O : Open Close Principle: Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. (Meyer Bertrand)

This concept dictates that you should never destroy code that is already written but only add new functionalities. This is a principle that take's into consideration the danger of altering working functionalities. The reason is that other parts of the software may rely on those functionalities the way they are. An example is that, imagine you need to change a car wheel but, surprise surprise, the wheel is welded onto the suspension of the vehicle. Now you need to be a PHD in mechanics to pool that off. Some times code is written in that way. The guy who did the suspension, when asked to implement the wheels, modified the suspension instead of creating new stuff. That leads to unmaintainable code. Instead of being a simple concept, this principle is one of the must broken in the SOLID design patterns. People have real difficult in taking this into account when writing software. Thing is, this must be done on the moment where the program is being written, that is, things must be done in a way were the principle can be executed. If you feel the necessity of changing structure, the mistake was already done in the past. The idea is to create generalized coupling that will account for future new functionalities without the need of changing existing other functionalities.

## L: Liskov Substitution Principle: The principle that subclasses should satisfy the expectation of clients assessing subclass objects through references of super-class type, not just as regards syntactic safety (such as absence of "method-not-found" errors) but also as regards behavioral correctness. (Barbara Liskov)

This principle concerns inheritance. When a class is inherited in other class, the subclass must conform with all methods and types that exists in the master class. This means that. It must accept all methods, even if such functionality don't apply to the given subclass (But this is a indicator that such subclass shouldn't be in the class. And a new master class should be implemented to this subclass). This can be exemplified with a new company looking to innovate in the car business with an acceleration pedal in the wrong place, like, in the left. When people take a car (class) they expect this pedal to be on the right position, but the car (subclass) from this company has it on the wrong place, this can cause problems for people causing crashes (both on real life and on the program kk). So when creating a car you must conform in all ways to the definitions of the class "car". The Solution would be create a new class for such unusual implementation. In a programming perspective there are some rules for guiding one on the good path:

- Preconditions (conditions that must be met by the input in order to enable the program execution) shouldn't be strengtened, that is, the subclass should not restrain more concerning the input data, that is, it should not be more demanding than the parental class.
- Postconditions (condition that must be met by the output in order to enable the program execution) shouldn't be weakened, that is, the subclass should not output data that wouldn't pass the parental class postconditions.

Aways think about polymorphic replacement with the base class when inheriting. Like, if a object ia a class S, and it is child of a class T, the objects of type T may be replaced with objects of class S.


## I: Interface Segregation Principle: Clients should not be forced to depend upon interfaces that they do not use. (Robert D. Martin).

When a program became too big it's normal to people to start making poor design decisions in the software development cycle. This results in unnecessary complexity, poor performance and bigger probabilities of error. So the right thing to do is to aways keep thinking and rethinking about the abstractions that are present in the program. An example of this is your smart phone. On there there are apps that are not used and there as some that were never used. Now, lets pretend that on the android there weren't options of customizing UI, like replacing icons and stuff. This would be a nightmare, like, you would be obligated to keep seeing those apps that you never use and you would have to keep scrolling through then to reach the desired app. This would cost you time, patience, and would increase the chances of you clicking in the wrong application. Shush bad reality wouldn't be conforming to the interface segregation principle. The solution is to give flexibility to the program and create the right abstractions in a way that only really needed code is executed when the program is used. This can be done with the right abstractions and separation of responsibilities. There should be interfaces for methods that are independent and that have clear functions. Is very important too to have a good dialog with the ones that will be using the software. All expansion possibilities must be took in consideration and abstractions and interfaces must be according to this. Large interfaces must be avoided too because they may introduce unnecessary coupling. 

## D: Dependency Inversion Principle: High-level modules should not depend on low-level modules. Both should depend on abstraction (e.g. Interfaces). Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions. 

Is considered the foundation of C# programming. In the real world this could be compared with a computer that has the mouse soldered in it's mother board. The right thing to do would be the implementation of the USB port, that is a interface with well established functional patterns that all mouse manufacturers follow. If by modifying a component you must modify the module that is dependent upon it than there is something wrong, and your interface is badly implemented. Low level stuff is code that implement raw functionalities. Like perform computations, make changes in database or memory, etc... High level modules are responsible for managing interfaces, and these interfaces are responsible for transforming high level commands of high level modules in low level instructions for these low level modules. This is very important to separate low layers of abstraction from the high ones. If you don't follow this principle chances are that you will need constantly to modify existing code with new low level implementations. This is unmaintainable on a sense that you need to understand both the module responsible for the low level functionality and all other low level functionalities that depend on the module that you must add the new implementation. This could be millions. To fix the problem you must write interfaces that isolate the calling process of the low level code. Something very important to this principle is the dependency injection technique that allows methods, properties and constructors to be passed from one class to another. This is the last principle and more sophisticated one and a tool to prevent other principles to be broken. It gives code more scalability and flexibility.


